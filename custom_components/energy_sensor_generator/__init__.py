import logging
import json
from pathlib import Path
from homeassistant.core import HomeAssistant, callback
from homeassistant.config_entries import ConfigEntry
from homeassistant.helpers import entity_registry as er
from homeassistant.helpers import device_registry as dr
from homeassistant.helpers.entity_platform import AddEntitiesCallback
from homeassistant.helpers.event import async_track_time_interval
from datetime import timedelta
from .sensor import EnergySensor, DailyEnergySensor, MonthlyEnergySensor
from .utils import load_storage, save_storage
from .const import DOMAIN, STORAGE_FILE
import voluptuous as vol

_LOGGER = logging.getLogger(__name__)

def detect_power_sensors(hass: HomeAssistant) -> list:
    """Detect power sensors using various criteria for broader detection."""
    entity_registry = er.async_get(hass)
    power_sensors = []
    
    # Get all entity states from Home Assistant
    all_states = hass.states.async_all()
    
    # Check for entities based on several criteria
    for state in all_states:
        entity_id = state.entity_id
        if not entity_id.startswith("sensor."):
            continue
            
        # Check if it looks like a power sensor
        is_power_sensor = False
        
        # 1. Check unit of measurement (most reliable)
        unit = state.attributes.get("unit_of_measurement", "")
        if unit in ["W", "w", "Watt", "watt", "Watts", "watts"]:
            is_power_sensor = True
            
        # 2. Check device class
        device_class = state.attributes.get("device_class", "")
        if device_class == "power":
            is_power_sensor = True
            
        # 3. Check entity naming patterns
        name_patterns = ["_power", "_consumption", "_usage", "power_", "watt"]
        if any(pattern in entity_id for pattern in name_patterns):
            # Only use name as indicator if numerical state is present
            try:
                float(state.state)
                is_power_sensor = True
            except (ValueError, TypeError):
                # Not a numerical sensor, so name pattern is not good enough
                pass
                
        # 4. Check for entity_registry entries with unit W or device_class power
        try:
            entity_reg = entity_registry.async_get(entity_id)
            if entity_reg and (entity_reg.unit_of_measurement == "W" or entity_reg.device_class == "power"):
                is_power_sensor = True
        except (KeyError, AttributeError):
            pass
            
        if is_power_sensor:
            power_sensors.append(entity_id)
            
    return power_sensors

def check_existing_energy_sensors(hass: HomeAssistant) -> dict:
    """Check for existing energy sensors and map them to their devices."""
    entity_registry = er.async_get(hass)
    device_registry = dr.async_get(hass)
    device_energy_sensors = {}
    
    # Get all entity states from Home Assistant
    all_states = hass.states.async_all()
    
    # Find energy sensors
    for state in all_states:
        entity_id = state.entity_id
        if not entity_id.startswith("sensor."):
            continue
            
        # Check if it's an energy sensor
        is_energy_sensor = False
        
        # Check unit of measurement
        unit = state.attributes.get("unit_of_measurement", "")
        if unit in ["kWh", "kwh"]:
            is_energy_sensor = True
            
        # Check device class
        device_class = state.attributes.get("device_class", "")
        if device_class == "energy":
            is_energy_sensor = True
            
        if is_energy_sensor:
            entity = entity_registry.async_get(entity_id)
            if entity and entity.device_id:
                # Add this sensor to the device's list of energy sensors
                if entity.device_id not in device_energy_sensors:
                    device_energy_sensors[entity.device_id] = []
                device_energy_sensors[entity.device_id].append(entity_id)
    
    return device_energy_sensors

def find_generated_sensors(hass: HomeAssistant) -> dict:
    """Find all energy sensors generated by this integration."""
    entity_registry = er.async_get(hass)
    result = {}
    
    # Look for entities with unique IDs that match our pattern
    for entity_id, entry in entity_registry.entities.items():
        if entry.platform == DOMAIN:
            # Get the base_name from the unique_id
            unique_id = entry.unique_id
            if unique_id.endswith("_energy") or unique_id.endswith("_daily_energy") or unique_id.endswith("_monthly_energy"):
                base_name = unique_id.replace("_energy", "").replace("_daily", "").replace("_monthly", "")
                if base_name not in result:
                    result[base_name] = []
                result[base_name].append(entity_id)
    
    return result

async def async_setup(hass: HomeAssistant, config: dict) -> bool:
    """Set up the Energy Sensor Generator component."""
    hass.data.setdefault(DOMAIN, {})
    
    return True

async def async_setup_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Set up Energy Sensor Generator from a config entry."""
    hass.data.setdefault(DOMAIN, {})

    # Setup storage path
    storage_path = Path(hass.config.path(STORAGE_FILE))
    
    # Store references in hass.data
    hass.data[DOMAIN][entry.entry_id] = {
        "config": entry.data,
        "storage": storage_path,
        "options": entry.options,
        "unsubscribers": [],
    }

    # Register generate service
    hass.services.async_register(
        DOMAIN, 
        "generate_sensors", 
        lambda call: generate_sensors_service(hass, call, entry)
    )
    
    await hass.config_entries.async_forward_entry_setup(entry, "sensor")
    
    # Set up periodic sampling for more accurate energy calculation
    sample_interval = entry.options.get("sample_interval", 60)
    
    # Start a periodic update task for power sensors
    async def sample_power_sensors(_now=None):
        """Sample power sensors periodically to improve accuracy."""
        # Get selected power sensors
        selected_sensors = entry.options.get("selected_power_sensors", [])
        if not selected_sensors:
            return
            
        _LOGGER.debug(f"Sampling {len(selected_sensors)} power sensors")
        for sensor_id in selected_sensors:
            state = hass.states.get(sensor_id)
            if state and state.state not in ("unknown", "unavailable"):
                # Force a state change event to trigger energy calculation
                await hass.helpers.entity_component.async_update_entity(sensor_id)
    
    if entry.options.get("selected_power_sensors"):
        interval = timedelta(seconds=sample_interval)
        unsub = async_track_time_interval(hass, sample_power_sensors, interval)
        hass.data[DOMAIN][entry.entry_id]["unsubscribers"].append(unsub)
    
    # Run generate_sensors_service with the current options
    if entry.options.get("selected_power_sensors"):
        await generate_sensors_service(hass, None, entry)
    
    return True
    
async def async_unload_entry(hass: HomeAssistant, entry: ConfigEntry) -> bool:
    """Unload a config entry."""
    # Cancel all periodic tasks
    for unsub in hass.data[DOMAIN][entry.entry_id].get("unsubscribers", []):
        unsub()
        
    unload_ok = await hass.config_entries.async_unload_platforms(entry, ["sensor"])
    if unload_ok:
        hass.data[DOMAIN].pop(entry.entry_id)
        
    return unload_ok

async def generate_sensors_service(hass: HomeAssistant, call, entry: ConfigEntry = None) -> None:
    """Service to generate energy sensors."""
    _LOGGER.info("Generating energy sensors")

    # Use the config entry from the call context if not provided
    if entry is None:
        # Try to get the first config entry for this domain
        entries = list(hass.data[DOMAIN].values())
        if not entries:
            _LOGGER.error("No config entry found for energy_sensor_generator.")
            return
        entry_data = entries[0]["config"]
        options = getattr(entries[0], "options", {})
        storage_path = entries[0]["storage"]
        async_add_entities = entries[0].get("async_add_entities")
    else:
        entry_data = entry.data
        options = entry.options
        storage_path = hass.data[DOMAIN][entry.entry_id]["storage"]
        async_add_entities = hass.data[DOMAIN][entry.entry_id].get("async_add_entities")

    # Get power sensors using more flexible detection
    all_power_sensors = detect_power_sensors(hass)
    _LOGGER.info(f"Auto-detected {len(all_power_sensors)} power sensors: {all_power_sensors}")

    # Use selected power sensors from options if present
    selected_sensors = options.get("selected_power_sensors") if options else None
    if selected_sensors:
        power_sensors = selected_sensors
        _LOGGER.info(f"Using manually selected power sensors: {power_sensors}")
    else:
        power_sensors = all_power_sensors
        _LOGGER.info(f"Using all detected power sensors: {power_sensors}")

    if not power_sensors:
        _LOGGER.warning("No power sensors found for energy sensor generation.")
        return

    # Check if we should create daily and monthly sensors
    create_daily = options.get("create_daily_sensors", True)
    create_monthly = options.get("create_monthly_sensors", True)
    
    # Find existing generated sensors
    existing_generated = find_generated_sensors(hass)
    _LOGGER.debug(f"Found {len(existing_generated)} existing generated sensor groups")
    
    # Get entity registry for operations
    entity_registry = er.async_get(hass)
    
    # First, remove sensors for power sources that are no longer selected
    base_names_to_keep = []
    for sensor in power_sensors:
        base_name = sensor.replace("sensor.", "").replace("_power", "")
        base_names_to_keep.append(base_name)
    
    # Remove entities that are no longer needed
    for base_name, entity_ids in existing_generated.items():
        if base_name not in base_names_to_keep:
            _LOGGER.info(f"Removing entities for {base_name} as it's no longer selected")
            for entity_id in entity_ids:
                entity_registry.async_remove(entity_id)
                _LOGGER.debug(f"Removed entity {entity_id}")
    
    # Check for existing energy sensors to avoid duplication
    device_energy_sensors = check_existing_energy_sensors(hass)

    entities = []
    storage = load_storage(storage_path)

    for sensor in power_sensors:
        base_name = sensor.replace("sensor.", "").replace("_power", "")
        
        # Check if we already have this base_name handled
        if base_name in existing_generated:
            # The sensors already exist - check if we need to remove daily/monthly
            existing_entities = existing_generated[base_name]
            
            daily_entity = next((e for e in existing_entities if "_daily_energy" in e), None)
            monthly_entity = next((e for e in existing_entities if "_monthly_energy" in e), None)
            
            # Remove daily if it exists but shouldn't
            if daily_entity and not create_daily:
                entity_registry.async_remove(daily_entity)
                _LOGGER.debug(f"Removed daily entity {daily_entity}")
                
            # Remove monthly if it exists but shouldn't
            if monthly_entity and not create_monthly:
                entity_registry.async_remove(monthly_entity)
                _LOGGER.debug(f"Removed monthly entity {monthly_entity}")
                
            # Skip this sensor as we've already handled it
            continue
        
        # Check if this device already has energy sensors
        entity = entity_registry.async_get(sensor)
        device_id = entity.device_id if entity else None
        
        if device_id and device_id in device_energy_sensors:
            _LOGGER.info(f"Device for {sensor} already has energy sensors: {device_energy_sensors[device_id]}")
            continue
        
        # Create Energy Sensor (kWh)
        energy_sensor = EnergySensor(hass, base_name, sensor, storage_path)
        entities.append(energy_sensor)

        # Create Daily and Monthly Sensors if enabled
        if create_daily:
            daily_sensor = DailyEnergySensor(hass, base_name, f"sensor.{base_name}_energy", storage_path)
            entities.append(daily_sensor)
            
        if create_monthly:
            monthly_sensor = MonthlyEnergySensor(hass, base_name, f"sensor.{base_name}_energy", storage_path)
            entities.append(monthly_sensor)

    # Add entities using the correct async_add_entities callback
    if async_add_entities and entities:
        async_add_entities(entities)
    elif not entities:
        _LOGGER.info("No new energy sensors to add.")
    else:
        _LOGGER.error("async_add_entities callback not found for adding entities")
